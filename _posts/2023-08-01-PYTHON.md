---
layout: single
title:  "python"

categories:
  - python
tags:
  - 
  
---
2.1 django
---

### 데이터를 관리하는 모델

장고는 모델로 데이터를 관리한다.  

#### 1. 장고 개발 서버 구동시 나오는 경고 메시지

```
(mysite) C:\projects\mysite>python manage.py runserver
Watching for file changes with StatReloader
Performing system checks...

System check identified no issues (0 silenced).

You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.
August 01, 2023 - 09:15:47
Django version 4.0.3, using settings 'config.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CTRL-BREAK.
```

#### 2.config/settings.py 설치된 app

```
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```

#### 3. config/settings.py에서 데이터베이스 정보

```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',      DB SQLite3
        'NAME': BASE_DIR / 'db.sqlite3',             BASE?????
    }
}
```

#### 4.앱이 필요로 하는 테이블 생성

```
migrate

(mysite) C:\projects\mysite>python mange.py migrate

Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying sessions.0001_initial... OK

```
#### DB Brower for SQLite

https://sqlitebrowser.org/dl/

![67](/assets/images/PYTHON/67.png)

#### 질문과 답변 모델을 생성

질문 모델

|속성명|설명|
|------|------|
|subject|질문 제목|
|content|질문 내용|
|create_date|질문 생성일|

ORM(Object Relation Mapping)

sql문으로 작성
전통적으로 데이터베이스를 사용하는 프로그램들은 데이터베이스의 데이터를 조회하거나 저장하기 위해 쿼리문을 사용해야 했다.   
이 방식은 여전히 많이 사용되고 있는 방식이지만 몇 가지 단점이 있다. 개발자마다 다양한 쿼리문이 만들어지고,  
또 잘못 작성된 쿼리는 시스템의 성능을 저하 시킬수 있기 때문이다. 그리고 데이터베이스를 MySQL에서 오라클로 변경하면 프로그램에서  
사용한 쿼리문을 모두 해당 데이터베이스의 규칙에 맞게 수정해야 하는 어려움도 생긴다.  

답변 모델

|속성명|설명|
|------|------|
|question|질문|
|content|답변 내용|
|create_date|답변 생성일|

#### pybo/models.py

```python
from django.db import models

# Create your models here.

class Question(models.Model):
    subject = models.CharField(max_length=200) # 가변형 문자열
    content = models.TextField() #글자수 제한이 없는 TextField
    create_date = models.DateTimeField() #날짜 + 시간

class Answer(models.Model):
    #Question이 삭제 될 경우 Answer(답변)도 같이 삭제
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    content = models.TextField()#글자수 제한이 없는 TextField
    create_date = models.DateTimeField()  # 날짜 + 시간
```

#### config/settings.py pybo 앱 등록

```python
INSTALLED_APPS = [
    'pybo.apps.PyboConfig', # 추가
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```

반드시 등록돼 있어야 한다.

#### migrate로 테이블 생성하기

```
(mysite) C:\projects\mysite>python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
  No migrations to apply.
  Your models in app(s): 'pybo' have changes that are not yet reflected in a migration, and so won't be applied.
  Run 'manage.py makemigrations' to make new migrations, and then re-run 'manage.py migrate' to apply them.
```

model이 변경되면 테이블 creation script가 필요

```python
# Generated by Django 4.0.3 on 2023-08-01 02:20

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Question',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('subject', models.CharField(max_length=200)),
                ('content', models.TextField()),
                ('create_date', models.DateTimeField()),
            ],
        ),
        migrations.CreateModel(
            name='Answer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('content', models.TextField()),
                ('create_date', models.DateTimeField()),
                ('question', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='pybo.question')),
            ],
        ),
    ]
```

```
(mysite) C:\projects\mysite>python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, pybo, sessions
Running migrations:
  Applying pybo.0001_initial... OK
```

실행되는 쿼리문 확인

```
(mysite) C:\projects\mysite>python manage.py sqlmigrate pybo 0001
BEGIN;
--
-- Create model Question
--
CREATE TABLE "pybo_question" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "subject" varchar(200) NOT NULL, "content" text NOT NULL, "create_date" datetime NOT NULL);
--
-- Create model Answer
--
CREATE TABLE "pybo_answer" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "content" text NOT NULL, "create_date" datetime NOT NULL, "question_id" bigint NOT NULL REFERENCES "pybo_question" ("id") DEFERRABLE INITIALLY DEFERRED);
CREATE INDEX "pybo_answer_question_id_e174c39f" ON "pybo_answer" ("question_id");
COMMIT;
```

#### 데이터 만들고 조회하기

##### 장고 shell을 이용

(mysite) C:\projects\mysite>python manage.py shell

```
(mysite) C:\projects\mysite>python manage.py shell
Python 3.8.6 (tags/v3.8.6:db45529, Sep 23 2020, 15:37:30) [MSC v.1927 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
```

#### Question, Answer모델 import

```
>>> from pybo.models import Question,Answer
>>> from django.utils import timezone
>>> q = Question(subject='pybo가 무엇인가요',content='pybo에 대해 알고 싶어요',create_date=timezone.now()) timezone.now():현재 날짜
>>> q.save()   모델을 저장
```

![68](/assets/images/PYTHON/68.png)

#### Qeustion 모델 데이터 모두 조회

```
>>> Question.objects.all()
<QuerySet [<Question: Question object (1)>, <Question: Question object (2)>]>
```

```python
class Question(models.Model):
    subject = models.CharField(max_length=200) # 가변형 문자열
    content = models.TextField() #글자수 제한이 없는 TextField
    create_date = models.DateTimeField() #날짜 + 시간

    def __str__(self):
        return self.subject + ', ' + self.create_date
```

#### CTRL + Z 창고 shell벗어 나기

```
>>> from pybo.models import Question,Answer
>>> Question.objects.all()
<QuerySet [<Question: pybo가 무엇인가요>, <Question: django가 무엇인가요>]>
```

```
>>> Question.objects.filter(id=1)
<QuerySet [<Question: pybo가 무엇인가요>]>
>>> Question.objects.get(id=1)
<Question: pybo가 무엇인가요>
```

#### 데이터 수정

데이터 조회  
조회된 데이터 수정  
저장

```
>>> q=Question.objects.get(id=2)
>>> q
>>> q.subject = '다음 시간은 즐거운 점심이다 ㅋ'
>>> q.save()
```

#### 데이터 삭제

데이터 조회  
삭제(delete())  

```
>>> q=Question.objects.get(id=1)
>>> q
>>> q.delete()
```

#### 연결된 데이터(FK) 처리

![69](/assets/images/PYTHON/69.png)

#### Answer 모델 데이터 만들기

![70](/assets/images/PYTHON/70.png)

#### Answer모델 데이터 조회

```
>>> from pybo.models import Question,Answer
>>> a=Answer.objects.get(id=1)
>>> a
```
#### 연결된 데이터로 조회하기
```
>>> a.question
<Question: 다음 시간은 즐거운 점심이다 ㅋ>
```
#### 연결된 데이터로 : 질문을 통해서 답변 찾기

```
answer_set

>>> q.answer_set.all()
<QuerySet [<Answer: Answer object (1)>]>
```

Question, Answer 모델 처럼 서로 연결되어 있으면 연결모델명_set 으로 연결됨  
데이터를 조회할 수 있다.












